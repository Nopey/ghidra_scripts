# Converts a VTable to an approximate C++ Header
#@author Magnus "Nopey" Larsen
#@category 
#@keybinding 
#@menupath Tools.Misc.VTable to C++ Header (Precise)
#@toolbar 

# Thanks to Fenteale for inspiring this with makeVtable.py
# https://github.com/Fenteale/GhidraVtableStructGenerator/blob/master/scripts/makeVtable.py

##
## ASKS and CONSTANTS
##

target_name = askString("VTable2CPP", "Target classname (ie: CBasePlayer)")
vtable_name = "__ZTV{}{}".format( len(target_name), target_name )

##
## IMPORTS, HELPER FNS
##
program = currentProgram # choose one program and stick to it
memory = program.getMemory()
symbol_table = currentProgram.getSymbolTable()
listing = currentProgram.getListing()
function_manager = currentProgram.getFunctionManager()

vtable_symbols = list(symbol_table.getGlobalSymbols(vtable_name))

# Crashes if no symbol matches, which is good.
vtable_symbol = vtable_symbols[0]
# if there's some to choose from, ask the user
if len(vtable_symbols) > 1:
    vtable_symbol = vtable_symbols[askInteger("VTable2CPP", "({}) matching symbols found.. Which one would you like?".format(len(vtable_symbols)))]
# we're done with that
del vtable_symbols

def apply_to_vts(vtable_symbol, fn):
    # skip the first 8 bytes, as they're just NULL (ptrdiff_t) followed by the typeinfo
    code_units = listing.getCodeUnits(vtable_symbol.getAddress().add( 8 ), True)
    while True:
        fs = next(code_units)

        valparts = fs.toString().split()
        if valparts[0] != "addr":
            # print("// halt: " + fs.toString())
            break

        function = function_manager.getFunctionContaining(vtable_symbol.getAddress().getNewAddress(int(valparts[1], 16)))
        if function == None:
            print("WARN: Function not found at address {}".format(valparts[1]))
            continue
        fn(function)


##
## MAIN
##

base_filename = "materialsystem"
shim_name = target_name + "Shim"
intf_name = "I" + target_name[1:]
intf_filename = "i{}.h".format(base_filename)
intf_file = open("/tmp/" + intf_filename, "w")
shim_file = open("/tmp/{}_shim.cpp".format(base_filename), "w")

# top of class
intf_file.write("// AUTOGENERATED BY preciseVTableToCPP.py\n")
intf_file.write("#pragma once\n")
intf_file.write("\n")
intf_file.write("typedef int undefined;\n")

opaque_types = set()
unknown_types = set()
def declare_types(function, recursed=False):
    params = function.getArguments() if recursed else function.getParameters() 
    for param in params:
        if not recursed and param.isAutoParameter():
            continue
        if type(param.getDataType()) is ghidra.program.database.data.StructureDB:
            name = param.getDataType().getName()
            if name in unknown_types:
                continue
            print("Unknown type: {}".format(name))
            unknown_types.add(name)
        elif type(param.getDataType()) is ghidra.program.database.data.TypedefDB:
            name = param.getDataType().getName()
            if name in unknown_types:
                continue
            intf_file.write("typedef {} {};\n".format(param.getDataType().getDataType(), name))
            unknown_types.add(name)
        elif type(param.getDataType()) is ghidra.program.database.data.PointerDB:
            t = param.getDataType()
            while type(t) is ghidra.program.database.data.PointerDB:
                t = t.getDataType()
            if type(t) is ghidra.program.database.data.FunctionDefinitionDB:
                intf_file.write("typedef {};\n".format(t.getPrototypeString()));
                declare_types(t, True)
                continue
            elif type(t) is not ghidra.program.database.data.StructureDB:
                continue
            name = t.getName()
            if name in opaque_types:
                continue
            intf_file.write("class {};\n".format(name))
            opaque_types.add(name)

apply_to_vts(vtable_symbol, declare_types)

intf_file.write("\n")
intf_file.write("class {}{{\n".format(intf_name))
intf_file.write("public:\n")

shim_file.write("// AUTOGENERATED BY preciseVTableToCPP.py\n")
shim_file.write("#include \"{}\"\n".format(intf_filename))
shim_file.write("\n")
shim_file.write("class {}: public {} {{\n".format(shim_name, intf_name))
shim_file.write("    {} *valve;\n".format( intf_name ))
shim_file.write("public:\n")
shim_file.write("    CMaterialSystemShim(IMaterialSystem *valve): valve(valve) {}\n")

def handle_fn(function):
    # formalSignature = True
    # includeCallingConvention = False
    signature = function.getPrototypeString( True, False )
    #TODO: Replace the `undefined` in the return type with a guess at the type via the decompiler?
    # ehhh... probably not
    intf_file.write("    virtual {} = 0;\n".format( signature ))


    param_names = ""
    for param in function.getParameters():
        if param.isAutoParameter():
            continue
        if param_names != "":
            param_names += ", "
        param_names += param.getName()

    shim_file.write("    virtual {} override {{\n".format( signature ))
    shim_file.write("        return valve->{}({});\n".format( function.getName(), param_names ))
    shim_file.write("    }\n")

apply_to_vts(vtable_symbol, handle_fn)

intf_file.write("};\n")
shim_file.write("};\n")
